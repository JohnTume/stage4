"use strict";

define(['ably', 'shared_helper', 'async'], function(Ably, helper, async) {
	var exports = {},
		_exports = {},
		displayError = helper.displayError,
		utils = helper.Utils,
		createPM = Ably.Realtime.ProtocolMessage.fromDeserialized,
		mixin = utils.mixin,
		closeAndFinish = helper.closeAndFinish,
		monitorConnection = helper.monitorConnection,
		testOnAllTransports = helper.testOnAllTransports;

	exports.setupTmp = function(test) {
		test.expect(1);
		helper.setupApp(function(err) {
			if(err) {
				test.ok(false, displayError(err));
			} else {
				test.ok(true, 'setup app');
			}
			test.done();
		});
	};

	exports.publishEncodings = function(test) {
		var testData = 'testData';
		var testArguments = [
			// valid
			[{name: 'justJson', encoding: 'json', data: '{\"foo\":\"bar\"}'}],
			// invalid -- encoding ending in utf-8 implies data is binary
			[{name: 'jsonUtf8string', encoding: 'json/utf-8', data: '{\"foo\":\"bar\"}'}],
			// valid
			[{name: 'utf8base64', encoding: 'utf-8/base64', data: 'dGVzdERhdGE='}],
			// invalid -- nonsense/corrupt encoding
			[{name: 'nonsense', encoding: 'choahofhpxf', data: testData}]
		];

		test.expect(testArguments.length * 4); // One for sending, one for receiving, one each for data & encoding
		try {
			/* set up realtime */
			var realtime = helper.AblyRealtime({log: {level: 4}});
			var rest = helper.AblyRest({log: {level: 4}});

			/* connect and attach */
			realtime.connection.on('connected', function() {
				var rtChannel = realtime.channels.get('publishEncodings');
				rtChannel.attach(function(err) {
					if(err) {
						test.ok(false, 'Attach failed with error: ' + displayError(err));
						closeAndFinish(test, realtime);
						return;
					}

					var subscribefn = function(cb) {
						var messagesReceived = 0;
						rtChannel.subscribe(function(msg) {
							test.ok(true, 'Received ' + msg.name);
							++messagesReceived;
							switch(msg.name) {
								case 'justJson':
									test.deepEqual(msg.data, {foo: "bar"}, 'justJson: correct decoded data');
									test.equal(msg.encoding, null, 'justJson: encoding stripped on decoding');
									break;
								case 'jsonUtf8string':
									test.equal(msg.data, '{\"foo\":\"bar\"}', 'justJsonUTF8string: data should be untouched');
									test.equal(msg.encoding, 'json/utf-8', 'justJsonUTF8string: encoding should be untouched');
									break;
								case 'utf8base64':
									test.equal(msg.data, "testData", 'utf8base64: correct decoded data');
									test.equal(msg.encoding, null, 'utf8base64: encoding stripped on decoding');
									break;
								case 'nonsense':
									test.deepEqual(msg.data, testData, 'nonsense: data untouched');
									test.equal(msg.encoding, 'choahofhpxf', 'nonsense: encoding untouched');
									break;
								default:
									test.ok(false, 'Unexpected message ' + msg.name + ' received');
									cb();
							}
							if (messagesReceived == testArguments.length) {
								cb();
							}
						});
					}

					/* publish events */
					var publishfn = function(cb) {
						var restChannel = rest.channels.get('publishEncodings');
						async.eachSeries(testArguments, function iterator(item, callback) {
							try {
								restChannel.publish(item, function(err) {
									test.ok(!err, "Successfully published");
									callback(err);
								});
							} catch (e) {
								test.ok(false, "Failed to publish");
							}
						}, cb);
					}

					async.parallel([subscribefn, publishfn], function() {
						closeAndFinish(test, realtime);
					})
				});
			});
			monitorConnection(test, realtime);
		} catch(e) {
			test.ok(false, 'Channel attach failed with exception: ' + e.stack);
			closeAndFinish(test, realtime);
		}
	};

	//for(var i=0; i<10; i++) {
		//exports['test_' + i] = exports.connectionDetails
	//}

	return module.exports = helper.withTimeout(exports);
});
